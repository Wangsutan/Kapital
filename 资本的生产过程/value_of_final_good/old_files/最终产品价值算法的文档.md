# 最终产品价值算法的文档

根据马克思经济学，不难理解，一件产品的价值，等于它所转移的生产资料的旧价值（或者说死劳动），加上新加入的劳动所形成的新价值（或者说活劳动）。因此，只要知道了以下数据，就可以计算出相应产品的总价值：

- 该产品的生产过程中使用到的各种劳动力所形成的劳动量。
- 劳动量的单位价值应该理解为单位1，这里写成每小时80的单价。
- 该产品的生产过程中使用到的各种生产资料（包括机器、工具、原料、燃料等等）的单位价值和使用量。
- 为了知道所使用的各种生产资料的价值，就相应地需要知道其各自的生产要素之价值和使用量，这个过程不断回溯，以至于在某类产品上，各种生产要素的价值都是明确的。

实例：茶叶蛋及前置产品。

茶叶蛋的生产要素（《茶叶蛋生产要素表_简单.xlsx》）：

| **生产要素** | **单位** | **数量** | **单价** |
| -------- | ------ | ------ | ------ |
| 劳动       | 小时     | 0.1    | 80     |
| 鸡蛋       | 个      | 10     | 0.98   |
| 八角       | 克      | 5      | 0.009  |
| 花椒       | 克      | 5      | 0.01   |
| 香叶       | 克      | 2      | 0.005  |
| 桂皮       | 克      | 2      | 0.006  |
| 小茴香      | 克      | 2      | 0.01   |
| 红茶       | 克      | 25     | 0.02   |
| 老抽       | 克      | 20     | 0.01   |
| 生抽       | 克      | 20     | 0.01   |
| 冰糖       | 克      | 10     | 0.02   |
| 盐        | 克      | 20     | 0.001  |
| 燃气       | 立方米    | 0.01   | 2.28   |
| 炊具       | 份      | 1      | 0.25   |
| 自然力      | 份      | 1      | 0      |

根据以上生产要素表，可以明确得知，一份茶叶蛋的价值等于每项生产要素的数量乘以单价的总和，即：

$$总价值 = \sum_1^n 数量_n \cdot 单价_n$$

在数学上，还可以理解为一维的数量矩阵与一维的单价矩阵之点积。

$$数量 \cdot 单价 = 数量_1单价_1 + 数量_2单价_2 + ... + 数量_n单价_n$$

---

我们运用dataframe相关数据结构来实现需求。

《生产要素的简单计算.py》

```python
import pandas as pd


filePath = '茶叶蛋生产要素表_简单.xlsx'
df = pd.read_excel(filePath, index_col='生产要素')

values = pd.DataFrame(df['数量'] * df['单价'], columns=['总价'])
print("values:", values)

value = df['数量'].dot(df['单价'])
print("\nvalue:", value)
```

运行结果：

```
values:           总价
生产要素        
劳动    8.0000
鸡蛋    9.8000
八角    0.0450
花椒    0.0500
香叶    0.0100
桂皮    0.0120
小茴香   0.0200
红茶    0.5000
老抽    0.2000
生抽    0.2000
冰糖    0.2000
盐     0.0200
燃气    0.0228
炊具    0.2500
自然力   0.0000

value: 19.329800000000002
```

就简单的需求而言，我们已经实现了自己的目的。

---

但是，现在有一个更复杂的问题，摆在我们面前。

茶叶蛋的生产资料中，可能有不是原初产品者。就是说，要生产这类生产资料本身，还需要在生产过程中加入别的劳动产品。比如，为了得到鸡蛋，我们还需要投入若干生产要素，如鸡圈、饲料、劳动等。因此，这类生产资料的单价，要上溯至这些更低一级生产要素的单价、数量以及总价。

我们设计了鸡蛋的生产要素表，并根据其中的数据，计算出鸡蛋（个）的单价是几何，再把这个单价代入茶叶蛋的生产要素表中计算。如果茶叶蛋的其他的特定生产要素也有这类情况，那么也按同样的算法来计算。工作也就完成了。

---

如何实现这种递归算法呢？

我们在生产要素表中，用字符`x`表示该生产要素的单价需要回溯。那么，如果有'x'，我们先要在单价列中遍历检索出'x'，然后找出其相应的生产要素名，然后根据生产要素名，搜寻其作为商品的生产要素表，然后在这个生产要素表中，继续检索单价列是否存在'x'，如果有，重复上述搜寻生产要素表的过程，然后，在该系列的递归得到单价列无'x'字符的生产要素表时，开始计算其价值，将价值返回给上一级的表，如果其上还有生产要素表，继续这个返回值的过程。这个过程是遍历的，使得一切'x'都被具体的数值所取代。如果没有'x'，就直接计算结果。

《生产要素的递归计算.py》

```
import pandas as pd


def search(good_before, goods_x):
    for good in goods_x:  # traversal all goods in this list
        print(good)  # this is the good now.
        filePath = good + "生产要素表.xlsx"
        globals()["df_" + good] = pd.read_excel(filePath, index_col="生产要素")
        goods_next = globals()["df_" + good].query("单价 == 'x'").index.tolist()

        if goods_next != []:
            print("Have other goods!")
            print("goods_next:", goods_next)
            search(good, goods_next)
        else:
            print("No other goods!")

        numbers = globals()["df_" + good]["数量"]
        values = globals()["df_" + good]["单价"]
        value = numbers.dot(values)
        if good_before != good:
            globals()["df_" + good_before].loc[good, '单价'] = value

        print("\n", good, globals()["df_" + good])
        print("value:", value)


good_before = "茶叶蛋"  # string
goods_x = ["茶叶蛋"]  # list
search(good_before, goods_x)
```

运行结果：

```
茶叶蛋
Have other goods!
goods_next: ['鸡蛋', '冰糖']
鸡蛋
Have other goods!
goods_next: ['饲料']
饲料
No other goods!

 饲料       单位      数量       单价
生产要素                     
机器     份  1.0000   0.0005
劳动    小时  0.0001  80.0000
自然力    份  1.0000   0.0000
value: 0.0085

 鸡蛋       单位       数量      单价
生产要素                     
鸡圈     份    1.000    0.08
饲料     克  100.000  0.0085
劳动    小时    0.005      80
自然力    份    1.000       0
value: 1.33
冰糖
No other goods!

 冰糖       单位      数量   单价
生产要素                 
劳动    小时  0.0001   80
机器     份  0.0001  100
自然力    份  1.0000    0
value: 0.018000000000000002

 茶叶蛋        单位     数量     单价
生产要素                   
劳动     小时   0.10     80
鸡蛋      个  10.00   1.33
八角      克   5.00  0.009
花椒      克   5.00   0.01
香叶      克   2.00  0.005
桂皮      克   2.00  0.006
小茴香     克   2.00   0.01
红茶      克  25.00   0.02
老抽      克  20.00   0.01
生抽      克  20.00   0.01
冰糖      克  10.00  0.018
盐       克  20.00  0.001
燃气    立方米   0.01   2.28
炊具      份   1.00   0.25
自然力     份   1.00      0
value: 22.809800000000003
```

---

递归所用的表格数据如下：

《茶叶蛋生产要素表.xlsx》

| **生产要素** | **单位** | **数量** | **单价** |
| -------- | ------ | ------ | ------ |
| 劳动       | 小时     | 0.1    | 80     |
| 鸡蛋       | 个      | 10     | x      |
| 八角       | 克      | 5      | 0.009  |
| 花椒       | 克      | 5      | 0.01   |
| 香叶       | 克      | 2      | 0.005  |
| 桂皮       | 克      | 2      | 0.006  |
| 小茴香      | 克      | 2      | 0.01   |
| 红茶       | 克      | 25     | 0.02   |
| 老抽       | 克      | 20     | 0.01   |
| 生抽       | 克      | 20     | 0.01   |
| 冰糖       | 克      | 10     | x      |
| 盐        | 克      | 20     | 0.001  |
| 燃气       | 立方米    | 0.01   | 2.28   |
| 炊具       | 份      | 1      | 0.25   |
| 自然力      | 份      | 1      | 0      |

《鸡蛋生产要素表.xlsx》

| **生产要素** | **单位** | **数量** | **单价** |
| -------- | ------ | ------ | ------ |
| 鸡圈       | 份      | 1      | 0.08   |
| 饲料       | 克      | 100    | x      |
| 劳动       | 小时     | 0.005  | 80     |
| 自然力      | 份      | 1      | 0      |

《饲料生产要素表.xlsx》

| **生产要素** | **单位** | **数量** | **单价** |
| -------- | ------ | ------ | ------ |
| 机器       | 份      | 1      | 0.0005 |
| 劳动       | 小时     | 0.0001 | 80     |
| 自然力      | 份      | 1      | 0      |

《冰糖生产要素表.xlsx》

| **生产要素** | **单位** | **数量** | **单价** |
| -------- | ------ | ------ | ------ |
| 劳动       | 小时     | 0.0001 | 80     |
| 机器       | 份      | 0.0001 | 100    |
| 自然力      | 份      | 1      | 0      |

还有一个《简单实例.xlsx》，可用来简单地测试：

| 生产要素 | 单位  | 数量  | 单价   |
| ---- | --- | --- | ---- |
| 劳动   | 小时  | 10  | 80   |
| 生产资料 | 份   | 1   | 1000 |
| 自然力  | 份   | 1   | 0    |

---

我们用这30行的代码，就可以实现如此复杂的关于最终产品价值的递归运算。从算法上讲，只要掌握了必要的数据，最终产品的价值都可计算出来，如果不考虑硬件和软件上的必然限制。

递归的过程比较复杂，建议读者自行Debug一下，加深理解。可以提示的是：整个过程是从最终产品中的下级产品出发，不断追溯（如果可能），直至获得了确切的数据结果，然后将这些数据又放回上一级的表中。最终的结果是，最终产品的表里没有不确定的数据，因而可以算出其价值。
