# 用程序化和算法化创造性地丰富和提高马克思的级差地租理论

土地的结构体是Soil，它包含以下字段：

- 土地名称，该字段用于标识该字段，便于获知其为什么土地，从而便于区分不同的土地。
- 土地面积，该字段指特定等级土地的总面积，或者对应最大可使用的面积。但它不代表该等级土地的实际使用面积。
- 土地使用面积，即实际使用的面积。
- 投资总额，在概念上可以认为投资总额先于单位面积投资额。知道了这个字段，就容易计算单位面积投资额。
- 总产量，一个非常重要的字段，有很多用途。
- 单位面积产量，一个重要的字段。
- 单位面积的单位投资的产量，一个特殊的概念。

---

该代码还需要一些参数，比如利润率、产品需求、供需是否均衡（布尔值）等。

可以通过命令行参数的形式，获取上述的参数。在现有的代码中，可以将利润率设为一个常量。

```
let profit_rate: f32 = 0.20;
```

有了这些基本的参数，还需要将诸等级的土地初始化。数据可以借用马克思那里的实例，也可以自主设置。

这里我们需要处理的对象是级差地租，因此，诸等级的土地按其土地生产力进行排序，就是必要的。排序的实际标准就是`单位面积的单位投资的产量`。结果是一个土地等级序列按土地生产力升序排列者，越往后，土地生产力越大。排序代码比较复杂，这里列举出来。

```
soil_list.sort_by(|a, b| {
    a.product_num_per_investment_per_area
        .partial_cmp(&b.product_num_per_investment_per_area)
        .unwrap()
});
```

有了上述的土地等级序列，就可以根据需求量，计算出来所能用到的最坏土地等级。这样的最坏土地等级不一定等于相应土地等级序列中的最坏土地等级。因为，当需求量较小，所需土地不那么多的时候，可能就不需要将某些更坏等级的土地投入生产。

现在我们来看获取实际使用土地中的最坏土地的那个函数。

```
fn get_min_soil(soil_list: &mut [Soil], product_demand: f32) -> (usize, f32, f32) {
    let mut i: usize = soil_list.len() - 1;
    let mut product_supply_possible: f32 = 0.0;
    let mut supply_rate_of_demand: f32;
    loop {
        product_supply_possible += soil_list[i].product_num_sum;
        println!(
            "[{}]\tproduct_supply_possible: {:.2}",
            i, product_supply_possible
        );
        soil_list[i].area_used = soil_list[i].area_sum;
        supply_rate_of_demand = product_supply_possible / product_demand;

        if product_supply_possible >= product_demand {
            return (i, product_supply_possible, supply_rate_of_demand);
        } else if (i == 0) && (product_supply_possible < product_demand) {
            return (i, product_supply_possible, supply_rate_of_demand);
        }
        i -= 1;
    }
}
```

为了获得这样的最坏土地，需要知道一切等级土地的相关性质，在程序上就是要读取Soil结构体所构成的列表。然后是产品的需求量，也是一个关键的参数。

这个函数的逻辑是这样的：

- 从最优土地开始，获取其可以生产的产品量，在代码上，实际上是将每个等级的土地的产品量，逐渐累加到总的可能供应量上。
- 判断这个产品量作为供应，能否满足产品需求。
- 如果这样的供给能满足需求，就返回相应的值。
- 如果这样的供给还不能满足需求，就拿到更坏一级的土地，将其产品量累加到可能供应的量上。再进行上述那样的判断过程。
- 但是，如果所有等级的土地都参与供应之后，仍然不能满足需求，就说明供不应求。此时，仍然返回相应的值。这样就在返回值方面保持了不同情况下的形式是一致的。

在上述这样的判断过程中，同时可以计算这些值：一是实际使用的最坏等级土地在Soil列表中的索引，这是该函数最核心的目的，二是可能供应的产品总量，三是一切等级土地之实际使用的土地面积，四是需求供给率。

最后的这个需求供给率`supply_rate_of_demand`，是一个重要的参数，它的值为供给量除以需求量。它反应了供需情况，或是供过于求，即大于1.0，或是供不应求，即小于1.0，或是供需均衡，即等于1.0。它还可以参与决定产品的市场价格，在这里具体来说，就是某种经过供需情况影响了的生产价格。

---

是否需要供需均衡`if_need_supply_demand_equilibrium`，是一个布尔值。它用于确定供需是否均衡。如果它为真，则需求供给率即为1.0。而这个需求供给率后面会决定某种生产价格。

经这个参数的调整，供给情况共能出现5种。程序中显性地给出了4种，其中三种的实际结果是需求供给率为1.0。隐性的1种情况是供给需求率本身即为1.0。在代码中，对于这种情况，隐性地保证该率仍为1.0。

---

现在我们来获取产品的价格。算法如下，体现为一个函数：

```
fn get_product_price(
    soil_investment: f32,
    soil_product_num: f32,
    profit_rate: f32,
    supply_rate_of_demand: f32,
) -> f32 {
    let product_price: f32 =
        (1.00 + profit_rate) * soil_investment / soil_product_num / supply_rate_of_demand;
    return product_price;
}

```

特定等级土地上的投资总额除以该土地上的总产量，得到单位产量上的投资额。这个值乘以`(1.0 + profit_rate)`，得到一种生产价格，因为生产价格就是在产品的生产费用基础上，再增加利润率所对应的一个价值增加部分。

现在得到的生产价格，还要受到需求供给率的调整。供不应求时，这个生产价格要上涨，供过于求时，它要下跌，供需均衡时，它保持不变。在代码中，这个值是除以需求供给率，因为：需求供给率越大，说明越是供过于求，于是生产价格要降低，反之，它越小，说明越是供不应求，于是生产价格要上升。

此外，我们无论如何再假定有一个想象中的均衡价格，此时，就是在需求供给率为1.0的情况下，按上述同样的方式，求出一个均衡的生产价格。

实际的生产价格与想象的均衡的生产价格之间，可以进行比较，从而参与得出超额利润率。

---

应该明白，实际使用的最坏土地的全部面积，不一定全都投入使用。可能的产品供给量与产品需求之间的差，只要存在正的解，就被视为该最坏土地的过剩供给，如果存在负的解，则理解为供不应求，因此该最坏土地的剩余供给为〇。

那么，该最坏土地的实际的产品供应量就等于其可能的产品供给量减去其过剩的产品供给量。无论这个过剩量是否为〇，算法是一致的。

用该最坏土地的实际的产品供应量，除以该最坏土地的单位面积产量，得到该最坏土地的过剩面积。

于是，在代码中，原来**假设**的那个最坏土地使用面积就得到实际的修正，要减去该最坏土地的过剩面积。

以上这个计算最坏土地实际使用面积的算法，具有一定的复杂性。它首先接受了一种假设，即假设最坏土地都已用上，然后再计算出过剩面积（其值可能为〇），再用全部面积转化成的假设的使用面积减去这个过剩面积，得出实际使用面积。这个算法看起来有些古怪，但优雅地保证了统一性和健壮性。

---

然后就是一本正经地计算出每级土地的产量、投资额、产值、超额利润等。然后，可以得出总产值和总超额利润。

应该清楚，这些数据被展示的方式，可以方便地复制出来，形成.csv文件。

```
soil_name, area_used, product_num_per_area, product_num_individual, investment, product_price, product_price_equilibrium, product_value_individual, super_profit_individual,
soil_A, 4, 1, 4, 200, 60.000004, 60.000004, 240.00002, 0,
soil_B, 4, 2, 8, 200, 60.000004, 60.000004, 480.00003, 240.00002,
soil_C, 2, 3, 6, 100, 60.000004, 60.000004, 360.00003, 240.00003,
soil_D, 2, 4, 8, 100, 60.000004, 60.000004, 480.00003, 360.00003,
```

展示这些数据的代码，应该不需要仔细讲解了。

---

超额利润得出以后，还可以考虑一个参数，就是从超额利润到地租的转化率。我们默认该转化率为1.0，就是说，我们假设全部超额利润都可以转化为地租。这只是一个假设，但是在这里的经济学模型中，是一个合理的假设。

注意，作为直接的计算结果，超额利润率有可能为负。条件是供过于求，即`supply_rate_of_demand > 1.0`，实际生产价格低于均衡生产价格。由于此前对需求供给率的实际处理，导致在该程序中需求供给率只能 <= 1.0。然而，如果当需求供给率大于1.0，并且不将其调整为1.0，那么，就会出现供过于求，于是超额利润为负。

我们通过下面的代码，始终保证超额利润转化成的总地租不为负数。因为在经济学上，就算农业资本家的土地产出甚至不能偿付其预付资本，土地所有者的地租仍然不能为负。

```
let rent_total: f32 = if rent_possible > 0.0 {
    rent_possible
} else {
    0.0
};
```

---

接下来，我们得出平均单位面积地租额，方式是总地租额除以总使用面积。我们还得出平均地租率，方式是总地租额除以总投资额。

---

该份代码不仅总结了马克思关于第一形式级差地租的理论，还额外增添了需求供给率、从超额利润到地租的转化率、均衡的生产价格等经济学的参数和关系，丰富和提高了马克思经济学的级差地租理论。
