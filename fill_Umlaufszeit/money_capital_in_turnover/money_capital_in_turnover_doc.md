 
劳动期间、流通期间、生产期间中的非劳动期间等等参数，同“再生产甘特图”。可调。每周预付资本数亦同。

下面，周转期间的长度乘以每周预付资本数，并赋值给货币资本参数。

将生产过程的开端处`0.0`和当时的货币资本数做成一个列表，进而放入货币资本位置的相关列表step_money_capital_list。

设定一个开始的指针，值为0，并放入相应的开始指针列表。

设定一个资本回流之指针列表。

假设周数变动之步长为1。（有时可设为0.5，比如《资本论》相关节中的第1个实例，劳动期间和流通期间皆为4.5时。）

步数列表的设计，是通过列表生成式。这里的步数列表，左边界为1，因为最初的开始点已经放到开始指针列表之中。右边界为`int(50 / step_length + turnover_time))`。右边界这样设计，是为了实现充分的右边空间。

用for循环遍历这个步数列表，执行相应循环体：

- 依据每周预付资本数和周步长，决定每次循环时货币资本减少的量。货币资本因而减少。

- 特定的步的值，连同减少了的货币资本的值，做成一个列表，添加进货币资本位置的相关列表step_money_capital_list。

- 下面通过`if_withdraw`函数，做特殊处理。

- 下面通过`get_begin_point`函数，做特殊处理。

---

`if_withdraw`：判断预付资本是否需要回流。

逆序开始指针列表，并用for循环遍历。

求出特定的步数step与开始指针列表中的特定指针的差，判断这个差是否等于周转时间。意思是，最后一个开始指针与现在所在位置的距离是相应的劳动期间的持续时间，如果这个时间等于周转期间，就说明，投入这个劳动期间的预付资本正好要回流。

如果这个条件为真，货币资本的值就应该增加，增加的值就等于劳动期间的长度乘以每周预付资本数。

在特定的时刻，追加的预付资本经过流通期间之后，一点也不剩了，货币资本的值为0。但与此同时，劳动期间所预付的货币资本现在正好回流。所以，在这个点上，存在两个关键节点，而这样一来，这两个节点所对应的周数是一致的。

现在，程序将这个时刻同时存在的资本回流的位置也记录下来，做成列表，添加进货币资本位置列表。

这个点是特殊的资本回流点。为此，程序记录下这个点对应的step值，添加到回流指针列表ptrs_withdraw。

然后，如果找到了这么一个回流点，就停下这个搜索过程，节省时间。

否则，遍历仍然继续，比对其他劳动期间开始的时刻。

如果遍历完成后仍然没有找到，就离开这个for循环，继而离开这个函数。

---

`get_begin_point`：获取劳动期间开始点。

如果所在的时刻能被劳动期间数所整除，就说明那个时刻是劳动期间开始点。0当然能被整除。这是最初的劳动期间开始点。由于在我们这里的理论设想中，劳动期间是连续的，那么，第1次以后的劳动期间之开始点之值，当然就以劳动期间本身的长度，从0不断增加。

---

现在，开始画图。

我们要先准备好横纵轴上的数据，为此，我们分开了货币资本位置列表中一一对应的步数和货币资本量，分别保存在相应列表中备用。

做好画布，根据“货币资本量图”的基本数据即步数和货币资本量所形成的点，画出基本的折线图。

然后，画出劳动期间开始时货币资本量的点。为此，我们需要根据劳动期间开始的时刻，通过函数`get_special_point_from`，获取相应的货币资本量数据。其他参数如代码所示。

然后，画出货币资本回流点。为此，我们需要根据预付资本回流的时刻，通过函数`get_special_point_from`，获取相应的货币资本量数据。注意，由于预付资本量回流的那个时刻上，存在两个关键节点，一个是货币资本量为0，一个是货币资本量为回流的预付资本量，则可以从后向前找，只找到我们需要的回流点的数据，而不找到预付资本用完的点的数据。其他参数如代码所示。

应该注意设置好x轴和y轴的刻度。x轴的刻度按照步列表的数据来设置，y轴的刻度按照货币资本量列表里的数据。

这里也使用网格线，方便查找、比较图中数据。

最后，展示该图。

---

`get_special_point_from`：根据特定的指针列表里的数据，查找嵌套的资源列表里对应的数据，返回目标列表。

这里运用了嵌套的for循环。外层for循环遍历特定指针列表，取出特定的指针。

内层for循环依次索引嵌套的资源列表。索引出来的东西是一个列表，即嵌套列表之中的列表。我们用`resources_list[i][0]`再次索引出这个列表中的第1个元素。用取出的特定指针比对该元素，如果相等，表明能找到特定的时刻所对应的货币资本额，那么，就用`resources_list[i][1]`再次索引出这个列表中的第2个元素。这个元素是货币资本量，存入目标列表。

如果真能找到，就可以离开内层for循环。但外层for循环依然存在，如果可以继续下去。

最终，这个函数返回目标列表，这个列表里存放了全部的找到了的货币资本量数据。
